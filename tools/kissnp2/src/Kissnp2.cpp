/*****************************************************************************
 *   discoSnp++: discovering polymorphism from raw unassembled NGS reads
 *   A tool from the GATB (Genome Assembly Tool Box)
 *   Copyright (C) 2014  INRIA
 *   Authors: P.Peterlongo, E.Drezen
 *
 *  This program is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU Affero General Public License as
 *  published by the Free Software Foundation, either version 3 of the
 *  License, or (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Affero General Public License for more details.
 *
 *  You should have received a copy of the GNU Affero General Public License
 *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *****************************************************************************/

#include <Kissnp2.hpp>
#include <Bubble.hpp>

using namespace std;

/********************************************************************************
 *
 * A QUICK OVERVIEW OF THE CLASS...
 *
 * This class implements the detection of SNP in a provided de Bruijn graph.
 *
 * It is implemented as a subclass of Tool, so we get all the facilities of the
 * Tool class. We can therefore see two main parts here:
 *
 * 1) constructor: we define all the command line parameters available
 *
 * 2) 'execute' method: this is the main method of the class where the main loop
 *   (ie. iteration over nodes of the graph) is done.
 *
 ********************************************************************************/

/*********************************************************************
 ** METHOD  :
 ** PURPOSE :
 ** INPUT   :
 ** OUTPUT  :
 ** RETURN  :
 ** REMARKS :
 *********************************************************************/
Kissnp2::Kissnp2 () : Tool ("Kissnp2")
{
    using gatb::core::tools::misc::impl::OptionNoParam;
    using gatb::core::tools::misc::impl::OptionOneParam;

    /** We add options known by kissnp2. */
    getParser()->push_front (new OptionNoParam  (STR_DISCOSNP_LOW_COMPLEXITY,       "conserve low complexity SNPs",     false));
    getParser()->push_front (new OptionOneParam (STR_MAX_AMBIGOUS_INDELS,           "Maximal size of ambiguity of INDELs. INDELS whose ambiguity is higher than this value are not output", false, "20"));
    getParser()->push_front (new OptionOneParam (STR_DISCOSNP_AUTHORISED_BRANCHING, "branching mode\n"
                                                 "\t\t0: forbid SNPs for wich any of the two paths is branching (high precision, low recall)\n"
                                                 "\t\t1: forbid SNPs for wich the two paths are branching (e.g. the two paths can be created either with a 'A' or a 'C' at the same position (default value)\n"
                                                 "\t\t2: No limitation on branching (low precision, high recall)",  false, "1"));
    getParser()->push_front (new OptionOneParam (STR_MAX_SYMMETRICAL_CROSSROADS,"In b2 mode only: maximal number of symmetrical croasroads traversed while trying to close a bubble. Default: no limit", false, "-1"));

    getParser()->push_front (new OptionNoParam  (STR_DISCOSNP_TRAVERSAL_UNITIG,     "extend found and stop at first polymorphism (strict extension=unitigs) SNPs. Uncompatible with -T",  false));
    getParser()->push_front (new OptionNoParam  (STR_DISCOSNP_TRAVERSAL_CONTIG,     "extend found and stop at large polymorphism (extension=contigs) SNPs. Uncompatible with -t",  false));
    getParser()->push_front (new OptionOneParam (STR_URI_OUTPUT,                    "output name",                      true));
    getParser()->push_front (new OptionOneParam (STR_KISSNP2_COVERAGE_FILE_NAME,    "File (.h5) generated by kissnp2, containing the coverage threshold per read set",                      false, "_removemeplease"));
    getParser()->push_front (new OptionOneParam (STR_URI_INPUT,                     "input file (likely a hdf5 file)",  true));
    getParser()->push_front (new OptionNoParam (STR_KISSNP2_DONT_OUTPUT_FIRST_COV, "Don't output the first coverage threshold. Use this option whent the refernece file is used for finding the variants",  false));
    
    
    getParser()->push_front (new OptionOneParam (STR_MAX_INDEL_SIZE,                "maximal size of a predicted indel", false, "0"));
    getParser()->push_front (new OptionOneParam (STR_MAX_POLYMORPHISM,              "maximal number of polymorphism per bubble", false, "1"));
    
    
    getParser()->push_back (new OptionOneParam (STR_BFS_MAX_DEPTH,   "maximum depth for BFS",    false,  "200"));
    getParser()->push_back (new OptionOneParam (STR_BFS_MAX_BREADTH, "maximum breadth for BFS",  false,  "20"));
    
}

/*********************************************************************
 ** METHOD  :
 ** PURPOSE :
 ** INPUT   :
 ** OUTPUT  :
 ** RETURN  :
 ** REMARKS :
 *********************************************************************/


/*
 *     // We load a Storage product "foo" in HDF5 format
    // It must have been created with the storage1 snippet
    Storage* storage = StorageFactory(STORAGE_HDF5).load ("foo");
    LOCAL (storage);
    // Shortcut: we get the root of this Storage object
    Group& root = storage->root();
    // We get a collection of native integer from the storage.
    Collection<NativeInt64>& myIntegers = root.getCollection<NativeInt64> ("myIntegers");
    // We create an iterator for our collection.
    Iterator<NativeInt64>* iter = myIntegers.iterator();
    LOCAL (iter);
    // Now we can iterate the collection through this iterator.
    for (iter->first(); !iter->isDone(); iter->next())  {  cout << iter->item() << endl;  }
    */
template <size_t span>
class MyApp : SpecializedGraphClient<span> {
public:

    void operator () (Kissnp2& tool) {
        typename BubbleFinderTemplate<span>::Graph graph = BubbleFinderTemplate<span>::Graph::load (tool.getGraphUri());

        /** We want to get some statistics about the execution. */
        typename BubbleFinderTemplate<span>::Stats stats;

        /** We create an instance of BubbleFinderTemplate, used as a functor by the dispatcher.
        * This instance will be cloned N times, one per thread created by the dispatcher.
        */
        BubbleFinderTemplate<span> bubbleFinder (tool.getInput(), graph, stats);

        /** THIS IS THE MAIN ITERATION LOOP... We launch the iteration over all the branching nodes of the graph.
        * Each iterated node is sent in one of N threads where it is provided to the operator() method
        * of one of the N BubbleFinderTemplate instance. */

        /** We get an iterator over the branching nodes of the graph. */
        dbg::ProgressGraphIterator<typename BubbleFinderTemplate<span>::BranchingNode, gatb::core::tools::misc::impl::ProgressTimer> it (graph.iteratorBranching(), "nodes");

        /** We get the number of nodes. */
        u_int64_t nbNodes = it.size();

        /** We loop the nodes. */
        gatb::core::tools::dp::impl::Dispatcher::Status status = tool.getDispatcher()->iterate (it, bubbleFinder);

        /** We aggregate information for user. */
        gatb::core::tools::misc::IProperties* info  = tool.getInfo();
        info->add (1, bubbleFinder.getConfig());
        info->add (1, "nodes",  "");
        info->add (2, "nb",   "%lu", nbNodes);
        info->add (1, "SNP bubbles",  "");
        info->add (2, "nb",      "%lu", stats.nb_bubbles_snp);
        info->add (2, "nb_high", "%lu", stats.nb_bubbles_snp_high);
        info->add (2, "nb_low",  "%lu", stats.nb_bubbles_snp_low);
        info->add (2, "extensions",  "");
        info->add (3, "none",       "%d", stats.nb_where_to_extend_snp[0]);
        info->add (3, "left",       "%d", stats.nb_where_to_extend_snp[1]);
        info->add (3, "right",      "%d", stats.nb_where_to_extend_snp[2]);
        info->add (3, "left|right", "%d", stats.nb_where_to_extend_snp[3]);
        info->add (1, "Indel bubbles",  "");
        info->add (2, "nb",      "%lu", stats.nb_bubbles_del);
        info->add (2, "nb_high", "%lu", stats.nb_bubbles_del_high);
        info->add (2, "nb_low",  "%lu", stats.nb_bubbles_del_low);
        info->add (2, "extensions",  "");
        info->add (3, "none",       "%d", stats.nb_where_to_extend_del[0]);
        info->add (3, "left",       "%d", stats.nb_where_to_extend_del[1]);
        info->add (3, "right",      "%d", stats.nb_where_to_extend_del[2]);
        info->add (3, "left|right", "%d", stats.nb_where_to_extend_del[3]);
        info->add (1, "time", "");
        info->add (2, "find", "%d", status.time);
    }
};


size_t Kissnp2::getKmerSize() const {
    using namespace gatb::core::tools::storage::impl;
    Storage* sto = StorageFactory(STORAGE_HDF5).create (graph_uri, false, false);
    string kmerSize_property = sto->getGroup("").getProperty ("kmer_size");
    delete sto;

    if (kmerSize_property.size() == 0) {
        cerr << "Unable to reak kmer size of graph '" << graph_uri << "'" << endl;
        exit(1);
    }

    return stoul(kmerSize_property);
}

void Kissnp2::execute ()
{
    graph_uri = getInput()->getStr(STR_URI_INPUT);
    gatb::core::tools::math::Integer::apply<MyApp, Kissnp2&>(getKmerSize(), *this);
//     cout <<  << endl;
    exit(0);


    
//     istringstream iss(graph.getInfo().getStr("thresholds"));
//
//     /** We store in a _removemeplease.txt file the used coverages */
//     // We create a Storage product "_removemeplease.h5" in HDF5 format
//     Storage* storage = StorageFactory(STORAGE_HDF5).create (getInput()->getStr(STR_KISSNP2_COVERAGE_FILE_NAME), true, false);
//     LOCAL (storage);
//     Group& root = storage->root();
//     Collection<NativeInt64>& myIntegers = root.getCollection<NativeInt64> ("cutoffs");
//
//     int n;
//     if (getInput()->get    (STR_KISSNP2_DONT_OUTPUT_FIRST_COV) != 0)
//         iss >> n; //Don't output the first coverage value
//
//     while (iss >> n)
//         myIntegers.insert (n);
//
//     myIntegers.flush();
//
    
    

    

}

